"""
FlightRiskRadar Data Analyst Agent - Google ADK Implementation
Handles BigQuery data analysis and SerpAPI integration using Google ADK
"""
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import requests
from google.cloud import bigquery
import google.generativeai as genai

# Import Google ADK - REAL IMPLEMENTATION ONLY
from google.adk.agents import Agent
from google.adk.tools import FunctionTool
print("‚úÖ Data Analyst Agent: Using real Google ADK")

# Import Google ADK Sub-Agents
from airport_complexity_agent import AirportComplexityAgent
from weather_impact_agent import WeatherImpactAgent

class DataAnalystAgent:
    """
    Google ADK Data Analyst Agent for flight data analysis
    """
    
    def __init__(self):
        self.name = "data_analyst_agent"
        self.description = "Analyzes flight data from BigQuery and SerpAPI using Google ADK"
        
        # Get SerpAPI key from environment variable
        self.serpapi_key = os.getenv('SERPAPI_API_KEY')
        if not self.serpapi_key:
            raise ValueError("SERPAPI_API_KEY environment variable is required")
        
        # Initialize BigQuery client
        try:
            self.bq_client = bigquery.Client()
            self.bq_available = True  # FIXED: Set bq_available to True when successful
            print("üîç Data Analyst Agent: BigQuery client initialized")
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: BigQuery init failed: {e}")
            self.bq_client = None
            self.bq_available = False  # FIXED: Set bq_available to False when failed
        
        # Initialize Google ADK Sub-Agents
        try:
            self.airport_complexity_agent = AirportComplexityAgent()
            self.weather_impact_agent = WeatherImpactAgent()
            print("üìä Data Analyst Agent: Google ADK sub-agents initialized")
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Failed to initialize ADK sub-agents: {e}")
            self.airport_complexity_agent = None
            self.weather_impact_agent = None
        
        print("üìä Google ADK Data Analyst Agent initialized")
    
    def analyze_route(self, origin, destination, date, connections=None):
        """Analyze route using SerpAPI"""
        try:
            # Call SerpAPI to get real flight data
            flight_data = self._call_serpapi_flights(origin, destination, date)
            
            if not flight_data:
                print(f"‚ùå Data Analyst Agent: No SerpAPI data available for {origin} ‚Üí {destination}")
                return {
                    'success': False,
                    'message': 'No flights found for this route',
                    'flights': []
                }
            
            # Extract and structure flight data
            structured_flights = self._extract_flight_data(flight_data, origin, destination, date)
            
            # Limit to maximum 10 flights
            original_count = len(structured_flights)
            if original_count > 10:
                structured_flights = structured_flights[:10]
                print(f"üìä Data Analyst Agent: Limited to 10 flights (was {original_count})")
            
            print(f"üìä Data Analyst Agent: Found {len(structured_flights)} flights")
            
            return {
                'success': True,
                'flights': structured_flights,
                'route_info': {
                    'origin': origin,
                    'destination': destination,
                    'date': date,
                    'connections': connections or []
                }
            }
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Route analysis failed: {e}")
            import traceback
            traceback.print_exc()
            return {
                'success': False,
                'message': f'Route analysis failed: {str(e)}',
                'flights': []
            }
    
    def get_flight_data_from_bigquery(self, airline_code, flight_number, date, airline_name, origin_airport_code=None, destination_airport_code=None):
        """
        Get flight data from BigQuery for direct flight lookup - Enhanced with 4-field matching
        CRITICAL: airline_name is now required (not optional)
        """
        print(f"üìä DATA ANALYST AGENT: Querying BigQuery for {airline_code}{flight_number} on {date}")
        print(f"üìä DATA ANALYST AGENT: Airline name: {airline_name}")
        print(f"üìä DATA ANALYST AGENT: Airport codes: {origin_airport_code} ‚Üí {destination_airport_code}")
        
        if not self.bq_available:
            print("‚ùå Data Analyst Agent: BigQuery not available")
            return None
        
        try:
            # UNIFIED QUERY: Both natural language and HTML forms use this same query
            query = f"""
            SELECT * FROM `argon-acumen-268900.airline_data.flight_data`
            WHERE UPPER(airline_code) = UPPER('{airline_code}') 
            AND UPPER(airline_name) = UPPER('{airline_name}')
            AND UPPER(CAST(flight_number AS STRING)) = UPPER('{flight_number}')
            AND DATE(departure_time_local) = '{date}'
            """
            
            print(f"üìä DATA ANALYST AGENT: Executing unified BigQuery query")
            print(f"üîç DATA ANALYST AGENT: Query: {query}")
            
            query_job = self.bq_client.query(query)
            results = query_job.result()
            
            # Convert results to list
            flight_data_list = []
            for row in results:
                flight_data_list.append(dict(row))
            
            if flight_data_list:
                flight_data = flight_data_list[0]  # Take the first matching flight
                print(f"‚úÖ DATA ANALYST AGENT: Found flight data in BigQuery")
                print(f"üìä DATA ANALYST AGENT: Flight: {flight_data.get('airline_name')} {flight_data.get('flight_number')}")
                print(f"üìä DATA ANALYST AGENT: Route: {flight_data.get('origin_airport_code')} ‚Üí {flight_data.get('destination_airport_code')}")
                
                # Convert layovers to connections format if they exist
                if 'layovers' in flight_data and flight_data['layovers']:
                    # Parse layovers if it's a JSON string
                    layovers_data = flight_data['layovers']
                    if isinstance(layovers_data, str):
                        try:
                            import json
                            layovers_data = json.loads(layovers_data)
                            print(f"üìä DATA ANALYST AGENT: Parsed layovers JSON string")
                        except json.JSONDecodeError as e:
                            print(f"‚ùå DATA ANALYST AGENT: Failed to parse layovers JSON: {e}")
                            layovers_data = []
                    
                    print(f"üìä DATA ANALYST AGENT: Converting {len(layovers_data)} layovers to connections format")
                    print(f"üîç DATA ANALYST AGENT: Layovers data type: {type(layovers_data)}, first item type: {type(layovers_data[0]) if layovers_data else 'N/A'}")
                    flight_data['connections'] = self._convert_layovers_to_connections_format(layovers_data)
                    print(f"‚úÖ DATA ANALYST AGENT: Converted layovers to connections: {flight_data['connections']}")
                elif 'connections' not in flight_data or flight_data['connections'] is None:
                    flight_data['connections'] = []
                    print(f"‚ÑπÔ∏è DATA ANALYST AGENT: No layovers or connections found")
                
                return flight_data
            else:
                print(f"‚ùå DATA ANALYST AGENT: No flight found in BigQuery")
                print(f"‚ùå DATA ANALYST AGENT: Search criteria - Airline: {airline_code}/{airline_name}, Flight: {flight_number}, Date: {date}")
            return None
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: BigQuery query failed: {e}")
            import traceback
            traceback.print_exc()
            return None

    def _convert_layovers_to_json_safe(self, layovers):
        """Convert layovers with datetime objects to JSON-safe format"""
        try:
            json_safe_layovers = []
            for layover in layovers:
                layover_dict = dict(layover)
                
                # Convert datetime objects to strings
                if 'arrival_time' in layover_dict and layover_dict['arrival_time']:
                    layover_dict['arrival_time'] = layover_dict['arrival_time'].strftime('%Y-%m-%d %H:%M:%S')
                
                if 'departure_time' in layover_dict and layover_dict['departure_time']:
                    layover_dict['departure_time'] = layover_dict['departure_time'].strftime('%Y-%m-%d %H:%M:%S')
                
                json_safe_layovers.append(layover_dict)
            
            return json_safe_layovers
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Failed to convert layovers: {e}")
            return []

    def _convert_layovers_to_connections_format(self, layovers):
        """Convert BigQuery layovers to the connections format the UI expects"""
        try:
            if not layovers:
                return []
                
            connections = []
            for layover in layovers:
                layover_dict = dict(layover)
                
                # Convert datetime objects to strings and format for UI
                arrival_time = layover_dict.get('arrival_time')
                departure_time = layover_dict.get('departure_time')
                
                connection = {
                    'city': layover_dict.get('city', 'Unknown'),  # City name like 'Houston', 'Las Vegas'
                    'airport': layover_dict.get('airport_code', 'Unknown'),  # Airport code like 'IAH', 'LAS'
                    'airport_code': layover_dict.get('airport_code', 'Unknown'),  # Airport code for compatibility
                    'duration': layover_dict.get('layover_duration_minutes', '0'),  # Layover duration
                    'travel_time': layover_dict.get('travel_time_minutes', '0'),  # Travel time to this airport
                    'arrival_time': arrival_time.strftime('%Y-%m-%d %H:%M:%S') if isinstance(arrival_time, datetime) else str(arrival_time) if arrival_time else '',
                    'departure_time': departure_time.strftime('%Y-%m-%d %H:%M:%S') if isinstance(departure_time, datetime) else str(departure_time) if departure_time else ''
                }
                connections.append(connection)
            
            return connections
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Failed to convert layovers to connections: {e}")
            return []
    
    def _call_serpapi_flights(self, origin, destination, date):
        """Call SerpAPI to get flight data"""
        print(f"üîç Data Analyst Agent: Searching flights {origin} ‚Üí {destination} on {date}")
        
        try:
            # Ensure date is in correct format (YYYY-MM-DD)
            formatted_date = self._format_date_for_serpapi(date)
            print(f"üîç Data Analyst Agent: Using formatted date: {formatted_date}")
            
            params = {
                'api_key': self.serpapi_key,
                'engine': 'google_flights',
                'departure_id': origin,
                'arrival_id': destination,
                'outbound_date': formatted_date,
                'type': '2',  # 2 = One way (not Round trip)
                'currency': 'USD',
                'hl': 'en'
            }
            
            print(f"üîç Data Analyst Agent: SerpAPI parameters: {params}")
            
            response = requests.get('https://serpapi.com/search', params=params, timeout=30)
            print(f"üîç Data Analyst Agent: SerpAPI response status: {response.status_code}")
            
            response.raise_for_status()
            
            data = response.json()
            print(f"üîç Data Analyst Agent: SerpAPI response keys: {list(data.keys())}")
            
            # Check for different response formats
            if 'best_flights' in data and data['best_flights']:
                print(f"‚úÖ Data Analyst Agent: Found {len(data['best_flights'])} best flights")
                return data
            elif 'other_flights' in data and data['other_flights']:
                print(f"‚úÖ Data Analyst Agent: Found {len(data['other_flights'])} other flights")
                return data
            elif 'flights' in data and data['flights']:
                print(f"‚úÖ Data Analyst Agent: Found {len(data['flights'])} flights")
                return data
            else:
                print("‚ö†Ô∏è Data Analyst Agent: No flights found in response")
                print(f"üîç Data Analyst Agent: Response data: {json.dumps(data, indent=2)}")
                
                # Check for error messages
                if 'error' in data:
                    print(f"‚ùå Data Analyst Agent: SerpAPI error: {data['error']}")
                
                return None
                
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Data Analyst Agent: Request failed - {str(e)}")
            return None
        except json.JSONDecodeError as e:
            print(f"‚ùå Data Analyst Agent: JSON decode failed - {str(e)}")
            return None
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: SerpAPI call failed - {str(e)}")
            import traceback
            traceback.print_exc()
            return None
    
    def _format_date_for_serpapi(self, date):
        """Format date for SerpAPI (YYYY-MM-DD format)"""
        try:
            # If already in YYYY-MM-DD format, return as is
            if isinstance(date, str) and len(date) == 10 and date.count('-') == 2:
                return date
            
            # Try to parse and format different date formats
            from datetime import datetime
            
            # Try different date formats
            date_formats = [
                '%Y-%m-%d',  # 2025-07-12
                '%m/%d/%Y',  # 07/12/2025
                '%B %d, %Y',  # July 12, 2025
                '%B %dth, %Y',  # July 12th, 2025
                '%B %dst, %Y',  # July 1st, 2025
                '%B %dnd, %Y',  # July 2nd, 2025
                '%B %drd, %Y',  # July 3rd, 2025
            ]
            
            for fmt in date_formats:
                try:
                    dt = datetime.strptime(date, fmt)
                    return dt.strftime('%Y-%m-%d')
                except ValueError:
                    continue
            
            # If no format matches, return original
            print(f"‚ö†Ô∏è Data Analyst Agent: Could not parse date format: {date}")
            return date
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Date formatting failed - {str(e)}")
            return date
    
    def _extract_flight_data(self, serpapi_data, origin, destination, date):
        """Extract and structure flight data from SerpAPI response"""
        flights = []
        
        try:
            best_flights = serpapi_data.get('best_flights', [])
            other_flights = serpapi_data.get('other_flights', [])
            all_flights = best_flights + other_flights
            
            for flight_data in all_flights:
                flight_info = self._parse_flight_info(flight_data, origin, destination, date)
                if flight_info:
                    flights.append(flight_info)
            
            print(f"üìä Data Analyst Agent: Extracted {len(flights)} flights")
            return flights
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Data extraction failed - {str(e)}")
            return []
    
    def _parse_flight_info(self, flight_data, origin, destination, date):
        """Parse individual flight information from SerpAPI"""
        try:
            # Extract basic flight info
            flights = flight_data.get('flights', [])
            if not flights:
                return None
            
            # Get airline info from first flight segment (origin flight)
            first_flight = flights[0]
            print(f"üîç DEBUG: SerpAPI first_flight keys: {list(first_flight.keys())}")
            airline_name = first_flight.get('airline', 'Unknown')
            flight_number = first_flight.get('flight_number', 'Unknown')
            
            # Extract airline code from flight number or map from airline name
            airline_code = self._extract_airline_code(flight_number, airline_name)
            
            # Clean flight number by removing airline code prefix to avoid duplication
            clean_flight_number = self._clean_flight_number(flight_number, airline_code)
            
            # Format flight number as airline code + number (e.g., "AA179")
            formatted_flight_number = f"{airline_code}{clean_flight_number}"
            print(f"üìä Data Analyst Agent: Formatted flight number: {formatted_flight_number} (from {flight_number})")
            
            # Extract departure and arrival info
            departure_airport = first_flight.get('departure_airport', {})
            arrival_airport = flights[-1].get('arrival_airport', {})
            
            departure_time = departure_airport.get('time', 'Unknown')
            arrival_time = arrival_airport.get('time', 'Unknown')
            
            # CRITICAL: Use total_duration from SerpAPI (not individual segment duration)
            total_duration_minutes = flight_data.get('total_duration', 0)
            duration = self._format_duration_from_minutes(total_duration_minutes) if total_duration_minutes > 0 else 'Unknown'
            print(f"üìä Data Analyst Agent: Total flight duration: {total_duration_minutes} minutes = {duration}")
            
            # Extract price
            price_info = flight_data.get('price', 0)
            
            # Extract aircraft from FIRST segment (origin flight)
            aircraft = first_flight.get('airplane', first_flight.get('aircraft', first_flight.get('aircraft_type', 'Unknown')))
            print(f"üìä Data Analyst Agent: Aircraft from first segment: {aircraft}")
            
            # Check for layovers from SerpAPI structure
            serpapi_layovers = flight_data.get('layovers', [])
            has_layovers = len(serpapi_layovers) > 0 or len(flights) > 1
            
            # Calculate connections and layovers for multi-segment flights
            connections = []
            layovers = []
            
            if has_layovers:
                print(f"üîó Data Analyst Agent: Processing {len(flights)} flight segments with {len(serpapi_layovers)} layovers")
                
                for i in range(len(flights)):
                    segment = flights[i]
                    segment_departure = segment.get('departure_airport', {})
                    segment_arrival = segment.get('arrival_airport', {})
                    
                    # Extract segment details
                    segment_duration = segment.get('duration', 0)
                    segment_aircraft = segment.get('airplane', segment.get('aircraft', 'Unknown'))
                    segment_flight_number = segment.get('flight_number', 'Unknown')
                    
                    # Format segment flight number
                    segment_airline_code = self._extract_airline_code(segment_flight_number, segment.get('airline', airline_name))
                    segment_clean_number = self._clean_flight_number(segment_flight_number, segment_airline_code)
                    segment_formatted_number = f"{segment_airline_code}{segment_clean_number}"
                    
                    # Create connection object
                    connection = {
                        'id': f'segment_{i}',
                        'flight_number': segment_formatted_number,
                        'aircraft': segment_aircraft,
                        'duration': self._format_duration_from_minutes(segment_duration),
                        'departure': {
                            'airport': {
                                'code': segment_departure.get('id', 'Unknown'),
                                'name': segment_departure.get('name', 'Unknown'),
                                'city': self._extract_city_from_airport_name(segment_departure.get('name', ''))
                            },
                            'time': segment_departure.get('time', 'Unknown')
                        },
                        'arrival': {
                            'airport': {
                                'code': segment_arrival.get('id', 'Unknown'),
                                'name': segment_arrival.get('name', 'Unknown'),
                                'city': self._extract_city_from_airport_name(segment_arrival.get('name', ''))
                            },
                            'time': segment_arrival.get('time', 'Unknown')
                        }
                    }
                    
                    # Add layover info if this is not the last segment
                    if i < len(flights) - 1 and i < len(serpapi_layovers):
                        # Use SerpAPI layover data directly
                        layover_data = serpapi_layovers[i]
                        layover_duration_minutes = layover_data.get('duration', 90)
                    
                    layover_info = {
                            'airport': layover_data.get('id', segment_arrival.get('id', 'Unknown')),
                            'airport_name': layover_data.get('name', segment_arrival.get('name', 'Unknown')),
                            'city': self._extract_city_from_airport_name(layover_data.get('name', segment_arrival.get('name', ''))),
                            'duration': self._format_duration_from_minutes(layover_duration_minutes),
                            'arrival_time': segment_arrival.get('time', ''),
                            'departure_time': flights[i + 1].get('departure_airport', {}).get('time', ''),
                            'overnight': layover_data.get('overnight', False)
                        }
                        
                        connection["layoverInfo"] = layover_info
                        
                        # Also add to layovers array for backward compatibility
                        layovers.append({
                            'airport': layover_info['airport'],
                            'airport_name': layover_info['airport_name'],
                            'city': layover_info['city'],
                            'duration': layover_info['duration'],
                            'arrival_time': layover_info['arrival_time'],
                            'departure_time': layover_info['departure_time'],
                            'travel_date': date
                        })
                    
                    connections.append(connection)
                
                print(f"‚úÖ Data Analyst Agent: Created {len(connections)} connections with {len(layovers)} layovers")
            else:
                print(f"‚úÖ Data Analyst Agent: Direct flight - no layovers")
            
            flight_info = {
                'airline_name': airline_name,
                'airline_code': airline_code,
                'flight_number': formatted_flight_number,  # Use formatted number (e.g., "AA179")
                'origin': origin,
                'destination': destination,
                'origin_airport_code': origin,
                'destination_airport_code': destination,
                'departure_time': departure_time,
                'arrival_time': arrival_time,
                'duration': duration,  # Total duration from SerpAPI
                'price': price_info,
                'aircraft': aircraft,  # Aircraft from first segment
                'layovers': layovers,
                'connections': connections,  # Add connections array
                'number_of_stops': len(layovers),  # Number of stops
                'total_duration': total_duration_minutes,
                'date': date,
                'data_source': 'SerpAPI',
                'type': flight_data.get('type', 'One way')  # Include flight type
            }
            
            return flight_info
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Failed to parse flight info: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def _format_duration(self, minutes):
        """
        Format duration from minutes to readable format - ORIGINAL LOGIC
        """
        try:
            minutes = int(minutes)
            hours = minutes // 60
            mins = minutes % 60
            
            if hours > 0 and mins > 0:
                return f"{hours}h {mins}m"
            elif hours > 0:
                return f"{hours}h"
            else:
                return f"{mins}m"
        except (ValueError, TypeError):
            return "0m"

    def _format_duration_from_minutes(self, minutes):
        """Format duration from minutes to readable format"""
        if minutes <= 0:
            return 'Unknown'
        
        hours = minutes // 60
        mins = minutes % 60
        
        if hours > 0 and mins > 0:
            return f"{hours}h {mins}m"
        elif hours > 0:
            return f"{hours}h"
        else:
            return f"{mins}m"
    
    def _calculate_duration(self, time1_str: str, time2_str: str) -> str:
        """Calculate duration between two time strings"""
        try:
            # Implementation would go here - calculate actual duration
            return '1h 30m'  # TODO: Implement proper calculation based on actual times
            
        except Exception:
            return 'Unknown'
    
    def _extract_city_from_airport_name(self, airport_name: str) -> str:
        """Extract city name from airport name (e.g., 'Los Angeles International Airport' -> 'Los Angeles')"""
        try:
            if not airport_name or airport_name == 'Unknown':
                return 'Unknown'
            
            # Remove common airport suffixes
            suffixes = ['International Airport', 'International', 'Airport', 'Regional', 'Municipal', 'Field']
            city = airport_name
            
            for suffix in suffixes:
                if city.endswith(suffix):
                    city = city[:-len(suffix)].strip()
            
            return city if city else 'Unknown'
            
        except Exception:
            return 'Unknown' 
    
    def _calculate_layover_minutes(self, arrival_time: str, departure_time: str) -> int:
        """Calculate layover duration in minutes between arrival and departure times"""
        try:
            if not arrival_time or not departure_time:
                return 90  # Default 1.5 hours if times not available
            
            # Parse times (format: "2025-07-18 09:30" or similar)
            from datetime import datetime
            
            # Try different time formats
            time_formats = [
                '%Y-%m-%d %H:%M',
                '%Y-%m-%d %H:%M:%S',
                '%Y-%m-%dT%H:%M:%S',
                '%Y-%m-%dT%H:%M:%SZ'
            ]
            
            arrival_dt = None
            departure_dt = None
            
            for fmt in time_formats:
                if not arrival_dt:
                    try:
                        arrival_dt = datetime.strptime(arrival_time, fmt)
                    except:
                        pass
                
                if not departure_dt:
                    try:
                        departure_dt = datetime.strptime(departure_time, fmt)
                    except:
                        pass
            
            if arrival_dt and departure_dt:
                # Calculate difference in minutes
                diff = departure_dt - arrival_dt
                minutes = int(diff.total_seconds() / 60)
                
                # Handle negative or very small layovers (likely next day)
                if minutes < 30:
                    minutes += 24 * 60  # Add 24 hours
                
                return minutes
            
            return 90  # Default if parsing fails
            
        except Exception as e:
            print(f"‚ö†Ô∏è Data Analyst Agent: Failed to calculate layover duration: {e}")
            return 90  # Default 1.5 hours
    
    def _extract_airline_code(self, flight_number: str, airline_name: str) -> str:
        """Extract airline code from flight number or map from airline name"""
        try:
            # First try to extract from flight number (e.g., "DL1590" ‚Üí "DL", "B6 615" ‚Üí "B6")
            if isinstance(flight_number, str) and len(flight_number) >= 2:
                # Check if flight number starts with letters and numbers
                import re
                # FIXED: Include both letters and numbers to capture codes like B6, AA, DL, etc.
                match = re.match(r'^([A-Z0-9]{1,3})', flight_number.upper())
                if match:
                    airline_code = match.group(1)
                    print(f"üìä Data Analyst Agent: Extracted airline code '{airline_code}' from flight number '{flight_number}'")
                    return airline_code
            
            # Fallback: Map airline name to code using common mappings
            airline_mapping = {
                'delta air lines': 'DL',
                'delta': 'DL',
                'american airlines': 'AA', 
                'american': 'AA',
                'united airlines': 'UA',
                'united': 'UA',
                'southwest airlines': 'WN',
                'southwest': 'WN',
                'jetblue airways': 'B6',
                'jetblue': 'B6',
                'alaska airlines': 'AS',
                'alaska': 'AS',
                'spirit airlines': 'NK',
                'spirit': 'NK',
                'frontier airlines': 'F9',
                'frontier': 'F9',
                'hawaiian airlines': 'HA',
                'hawaiian': 'HA',
                'allegiant air': 'G4',
                'allegiant': 'G4'
            }
            
            airline_key = airline_name.lower().strip()
            if airline_key in airline_mapping:
                airline_code = airline_mapping[airline_key]
                print(f"üìä Data Analyst Agent: Mapped airline name '{airline_name}' to code '{airline_code}'")
                return airline_code
            
            # If no mapping found, try to guess from first letters
            if isinstance(airline_name, str) and len(airline_name) >= 2:
                words = airline_name.upper().split()
                if len(words) >= 2:
                    airline_code = words[0][:1] + words[1][:1]  # e.g., "Virgin America" ‚Üí "VA"
                    print(f"üìä Data Analyst Agent: Guessed airline code '{airline_code}' from '{airline_name}'")
                    return airline_code
            
            print(f"‚ö†Ô∏è Data Analyst Agent: Could not determine airline code for '{airline_name}' / '{flight_number}'")
            return 'Unknown'
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Airline code extraction failed: {e}")
            return 'Unknown'
    
    def _clean_flight_number(self, flight_number: str, airline_code: str) -> str:
        """Remove airline code prefix from flight number to avoid duplication"""
        try:
            if not flight_number or not airline_code or airline_code == 'Unknown':
                return flight_number
            
            # Convert to uppercase for comparison
            flight_upper = flight_number.upper().strip()
            airline_upper = airline_code.upper().strip()
            
            # Remove airline code prefix (e.g., "AS 41" ‚Üí "41", "DL1732" ‚Üí "1732")
            if flight_upper.startswith(airline_upper):
                clean_number = flight_upper[len(airline_upper):].strip()
                # Remove leading space or non-alphanumeric chars
                import re
                clean_number = re.sub(r'^[^A-Z0-9]+', '', clean_number)
                
                # If we have a number left, return it, otherwise return original
                if clean_number:
                    print(f"üìä Data Analyst Agent: Cleaned flight number: {flight_number} ‚Üí {clean_number}")
                    return clean_number
            
            # If no cleaning needed or cleaning failed, return original
            return flight_number
            
        except Exception as e:
            print(f"‚ùå Data Analyst Agent: Flight number cleaning failed: {e}")
            return flight_number
 